# Документация по Performance Testing

## Обзор

Этот документ описывает настройку performance testing для ERP системы, включая тестовые сценарии, стратегии мониторинга и рекомендации по оптимизации.

## Инфраструктура тестирования

### Используемые инструменты
- **Artillery** - Фреймворк для нагрузочного тестирования
- **Пользовательские скрипты** - Автоматизация и отчетность
- **Системный мониторинг** - Отслеживание использования ресурсов

### Настройка тестовой среды

1. **Запуск сервера приложения:**
```bash
npm run start:dev
```

2. **Запуск performance тестов:**
```bash
./scripts/run-performance-tests.sh
```

## Тестовые сценарии

### 1. Базовый нагрузочный тест (`basic-load-test.yaml`)
- **Цель:** Измерение базовой производительности
- **Длительность:** 4 минуты всего
- **Паттерн нагрузки:** 5→10→5 RPS нарастание/спад
- **Основные операции:**
  - Аутентификация
  - Расчет цен
  - Создание заказов

### 2. Тест concurrent пользователей (`concurrent-users-test.yaml`)
- **Цель:** Симуляция реальных concurrent пользователей
- **Длительность:** 5.5 минут всего
- **Паттерн нагрузки:** Постепенное нарастание до пиковой нагрузки
- **Сценарии:**
  - Расчет цен со случайными параметрами
  - Полный workflow управления заказами
  - Операции с интенсивной нагрузкой на БД

## Ключевые метрики производительности

### Метрики времени отклика
- **Среднее время отклика** - Общий индикатор производительности
- **95-й процентиль** - Мера качества пользовательского опыта
- **Максимальное время отклика** - Граница емкости системы
- **Минимальное время отклика** - Лучшая производительность

### Метрики пропускной способности
- **Запросы в секунду (RPS)** - Емкость обработки системы
- **Транзакции в секунду** - Пропускная способность бизнес-операций
- **Частота ошибок** - Индикатор надежности системы

### Использование ресурсов
- **Использование CPU** - Утилизация вычислительной мощности
- **Потребление памяти** - Эффективность использования RAM
- **Соединения с БД** - Нагрузка на уровень персистентности
- **Сетевой I/O** - Накладные расходы на коммуникацию

## Стратегия мониторинга

### Команды мониторинга в реальном времени

**Системные ресурсы:**
```bash
# CPU и память
top -o cpu

# Сетевая активность
netstat -i

# Дисковый I/O
iostat -x 1
```

**Логи приложения:**
```bash
# Просмотр логов приложения во время тестирования
tail -f logs/application.log

# Мониторинг запросов к БД
tail -f logs/database.log
```

### Пользовательский скрипт мониторинга
Создайте `monitor-performance.sh`:
```bash
#!/bin/bash
while true; do
    echo "$(date): $(curl -s http://localhost:3000/health)"
    sleep 5
done
```

## Рекомендации по оптимизации производительности

### Оптимизация БД
1. **Анализ запросов:**
   - Включить логирование медленных запросов
   - Анализировать планы выполнения
   - Оптимизировать часто используемые запросы

2. **Стратегия индексации:**
   - Создавать индексы на часто запрашиваемые колонки
   - Мониторить статистику использования индексов
   - Регулярное обслуживание индексов

### Оптимизации на уровне приложения

1. **Стратегия кэширования:**
   - Реализовать кэширование Redis для модификаторов цен
   - Кэшировать часто запрашиваемые данные продуктов
   - Использовать инвалидацию кэша на основе TTL

2. **Пулинг соединений:**
   - Настроить оптимальные размеры пулов
   - Мониторить паттерны использования соединений
   - Реализовать обнаружение утечек соединений

3. **Асинхронная обработка:**
   - Выносить тяжелые вычисления в фоновые задачи
   - Реализовать обработку на основе очередей
   - Использовать стриминг для операций с большими наборами данных

## Workflow выполнения тестов

### Предтестовый чеклист
- [ ] Сервер приложения запущен
- [ ] База данных доступна
- [ ] Тестовые данные подготовлены
- [ ] Инструменты мониторинга настроены
- [ ] Процедуры резервного копирования на месте

### Шаги выполнения тестов
1. **Подготовка окружения**
   ```bash
   # Очистка кэшей
   npm run cache:clear
   
   # Сброс тестовой базы данных
   npm run db:reset-test
   ```

2. **Измерение базовых показателей**
   ```bash
   ./scripts/run-performance-tests.sh basic
   ```

3. **Нагрузочное тестирование**
   ```bash
   ./scripts/run-performance-tests.sh concurrent
   ```

4. **Стресс-тестирование**
   ```bash
   # Запуск расширенного нагрузочного теста
   artillery run performance-tests/stress-test.yaml
   ```

### Пост-тестовый анализ
1. **Генерация отчетов**
   - HTML отчеты для заинтересованных сторон
   - JSON данные для детального анализа
   - Сравнительные диаграммы и графики

2. **Сбор метрик**
   - Распределения времени отклика
   - Паттерны ошибок и частоты
   - Тренды использования ресурсов

3. **Анализ первопричин**
   - Корреляция проблем производительности с системными событиями
   - Выявление узких мест в цепочках обработки
   - Документирование возможностей оптимизации

## Непрерывный мониторинг производительности

### Интеграция с CI/CD
Добавьте performance тесты в pipeline деплоя:
```yaml
# .github/workflows/performance-test.yml
name: Performance Tests
on: [push, pull_request]

jobs:
  performance-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Setup Node.js
        uses: actions/setup-node@v2
      - name: Install dependencies
        run: npm ci
      - name: Run performance tests
        run: ./scripts/run-performance-tests.sh
      - name: Upload results
        uses: actions/upload-artifact@v2
        with:
          name: performance-results
          path: performance-results/
```

### Пороговые значения для алертов
Настройте автоматические алерты для:
- Время отклика > 2000ms
- Частота ошибок > 1%
- Использование CPU > 80%
- Использование памяти > 85%

## Руководство по устранению неполадок

### Распространенные проблемы и решения

**Высокое время отклика:**
- Проверить пулинг соединений с БД
- Проанализировать планы выполнения запросов
- Пересмотреть стратегию кэширования приложения

**Высокая частота ошибок:**
- Мониторить логи приложения на наличие исключений
- Проверить подключение к БД
- Валидировать доступность endpoint'ов API

**Исчерпание ресурсов:**
- Увеличить лимиты системных ресурсов
- Оптимизировать распределение памяти
- Реализовать пулинг соединений

### Команды отладки
```bash
# Проверка здоровья приложения
curl http://localhost:3000/health

# Мониторинг активных соединений
netstat -an | grep :3000 | wc -l

# Проверка соединений с БД
psql -c "SELECT count(*) FROM pg_stat_activity;"

# Просмотр недавних ошибок
journalctl -u erp-app --since "1 hour ago" | grep ERROR
```

## Бенчмарки производительности

### Целевые метрики
| Метрика | Цель | Критический порог |
|---------|------|-------------------|
| Среднее время отклика | < 500ms | > 2000ms |
| 95-й процентиль | < 1000ms | > 3000ms |
| Частота ошибок | < 0.1% | > 1% |
| Емкость RPS | > 50 RPS | N/A |

### Исторические данные производительности
Ведите учет:
- Трендов производительности со временем
- Влияния изменений кода
- Сезонных паттернов использования
- Эффектов аппаратных обновлений

---
*Версия документа: 1.0*
*Последнее обновление: Январь 2026*