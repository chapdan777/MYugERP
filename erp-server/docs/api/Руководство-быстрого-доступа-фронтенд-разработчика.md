# Руководство быстрого доступа для фронтенд-разработчиков

## Начало работы

### Установка
```bash
# Установка необходимых зависимостей
npm install axios react-query @types/react
```

### Базовая настройка API клиента
```javascript
// src/services/api.js
import axios from 'axios';

const API_BASE_URL = 'https://api.erp-system.com/v1';

export const api = axios.create({
  baseURL: API_BASE_URL,
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json'
  }
});

// Интерцептор запросов для аутентификации
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('accessToken');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Интерцептор ответов для обновления токена
api.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;
    
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;
      
      try {
        const refreshToken = localStorage.getItem('refreshToken');
        const response = await axios.post(`${API_BASE_URL}/auth/refresh`, {
          refreshToken
        });
        
        const { accessToken, refreshToken: newRefreshToken } = response.data;
        localStorage.setItem('accessToken', accessToken);
        localStorage.setItem('refreshToken', newRefreshToken);
        
        originalRequest.headers.Authorization = `Bearer ${accessToken}`;
        return api(originalRequest);
      } catch (refreshError) {
        localStorage.clear();
        window.location.href = '/login';
        return Promise.reject(refreshError);
      }
    }
    
    return Promise.reject(error);
  }
);

export default api;
```

## Общие паттерны

### 1. Хук CRUD операций
```javascript
// src/hooks/useCrud.js
import { useState } from 'react';
import api from '../services/api';

export const useCrud = (resource) => {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const create = async (data) => {
    setLoading(true);
    setError(null);
    try {
      const response = await api.post(`/${resource}`, data);
      return response.data;
    } catch (err) {
      setError(err.response?.data?.message || 'Операция не удалась');
      throw err;
    } finally {
      setLoading(false);
    }
  };

  const read = async (id) => {
    setLoading(true);
    setError(null);
    try {
      const response = await api.get(`/${resource}/${id}`);
      return response.data;
    } catch (err) {
      setError(err.response?.data?.message || 'Не удалось получить данные');
      throw err;
    } finally {
      setLoading(false);
    }
  };

  const update = async (id, data) => {
    setLoading(true);
    setError(null);
    try {
      const response = await api.put(`/${resource}/${id}`, data);
      return response.data;
    } catch (err) {
      setError(err.response?.data?.message || 'Обновление не удалось');
      throw err;
    } finally {
      setLoading(false);
    }
  };

  const remove = async (id) => {
    setLoading(true);
    setError(null);
    try {
      await api.delete(`/${resource}/${id}`);
      return true;
    } catch (err) {
      setError(err.response?.data?.message || 'Удаление не удалось');
      throw err;
    } finally {
      setLoading(false);
    }
  };

  const list = async (params = {}) => {
    setLoading(true);
    setError(null);
    try {
      const response = await api.get(`/${resource}`, { params });
      return response.data;
    } catch (err) {
      setError(err.response?.data?.message || 'Не удалось получить список');
      throw err;
    } finally {
      setLoading(false);
    }
  };

  return {
    create,
    read,
    update,
    remove,
    list,
    loading,
    error
  };
};
```

### 2. Хук пагинации
```javascript
// src/hooks/usePagination.js
import { useState, useEffect } from 'react';
import { useCrud } from './useCrud';

export const usePagination = (resource, initialParams = {}) => {
  const [page, setPage] = useState(1);
  const [limit, setLimit] = useState(20);
  const [total, setTotal] = useState(0);
  const [pages, setPages] = useState(0);
  const [data, setData] = useState([]);
  
  const crud = useCrud(resource);

  const fetchPage = async (pageNum = page, pageLimit = limit) => {
    try {
      const response = await crud.list({
        page: pageNum,
        limit: pageLimit,
        ...initialParams
      });
      
      setData(response.data);
      setTotal(response.pagination.total);
      setPages(response.pagination.pages);
      setPage(pageNum);
      setLimit(pageLimit);
      
      return response;
    } catch (error) {
      console.error('Ошибка получения страницы:', error);
      throw error;
    }
  };

  const nextPage = () => {
    if (page < pages) {
      fetchPage(page + 1);
    }
  };

  const prevPage = () => {
    if (page > 1) {
      fetchPage(page - 1);
    }
  };

  const goToPage = (pageNum) => {
    if (pageNum >= 1 && pageNum <= pages) {
      fetchPage(pageNum);
    }
  };

  useEffect(() => {
    fetchPage();
  }, []);

  return {
    data,
    page,
    limit,
    total,
    pages,
    hasNext: page < pages,
    hasPrev: page > 1,
    nextPage,
    prevPage,
    goToPage,
    fetchPage,
    loading: crud.loading,
    error: crud.error
  };
};
```

### 3. Контекст аутентификации
```javascript
// src/context/AuthContext.js
import React, { createContext, useContext, useState, useEffect } from 'react';
import api from '../services/api';

const AuthContext = createContext();

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth должен использоваться внутри AuthProvider');
  }
  return context;
};

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const token = localStorage.getItem('accessToken');
    if (token) {
      getCurrentUser();
    } else {
      setLoading(false);
    }
  }, []);

  const getCurrentUser = async () => {
    try {
      const response = await api.get('/auth/me');
      setUser(response.data);
    } catch (error) {
      localStorage.removeItem('accessToken');
      localStorage.removeItem('refreshToken');
    } finally {
      setLoading(false);
    }
  };

  const login = async (credentials) => {
    try {
      const response = await api.post('/auth/login', credentials);
      const { accessToken, refreshToken, user } = response.data;
      
      localStorage.setItem('accessToken', accessToken);
      localStorage.setItem('refreshToken', refreshToken);
      setUser(user);
      
      return user;
    } catch (error) {
      throw error;
    }
  };

  const logout = async () => {
    try {
      await api.post('/auth/logout');
    } catch (error) {
      console.error('Ошибка выхода:', error);
    } finally {
      localStorage.removeItem('accessToken');
      localStorage.removeItem('refreshToken');
      setUser(null);
    }
  };

  const value = {
    user,
    login,
    logout,
    isAuthenticated: !!user,
    loading
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
};
```

## Примеры React компонентов

### 1. Компонент защищенного маршрута
```javascript
// src/components/ProtectedRoute.js
import React from 'react';
import { Navigate } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

const ProtectedRoute = ({ children, requiredRole }) => {
  const { isAuthenticated, user, loading } = useAuth();

  if (loading) {
    return <div>Загрузка...</div>;
  }

  if (!isAuthenticated) {
    return <Navigate to="/login" replace />;
  }

  if (requiredRole && user?.role !== requiredRole) {
    return <Navigate to="/unauthorized" replace />;
  }

  return children;
};

export default ProtectedRoute;
```

### 2. Компонент таблицы данных
```javascript
// src/components/DataTable.js
import React from 'react';
import { usePagination } from '../hooks/usePagination';

const DataTable = ({ 
  resource, 
  columns, 
  filters = {},
  renderActions 
}) => {
  const {
    data,
    page,
    limit,
    total,
    pages,
    hasNext,
    hasPrev,
    nextPage,
    prevPage,
    goToPage,
    loading,
    error
  } = usePagination(resource, filters);

  if (loading) return <div className="loading">Загрузка...</div>;
  if (error) return <div className="error">Ошибка: {error}</div>;

  return (
    <div className="data-table">
      <table>
        <thead>
          <tr>
            {columns.map(column => (
              <th key={column.key}>{column.label}</th>
            ))}
            {renderActions && <th>Действия</th>}
          </tr>
        </thead>
        <tbody>
          {data.map(item => (
            <tr key={item.id}>
              {columns.map(column => (
                <td key={column.key}>
                  {column.render ? column.render(item[column.key], item) : item[column.key]}
                </td>
              ))}
              {renderActions && (
                <td>{renderActions(item)}</td>
              )}
            </tr>
          ))}
        </tbody>
      </table>

      {/* Элементы управления пагинацией */}
      <div className="pagination">
        <button onClick={prevPage} disabled={!hasPrev}>
          Назад
        </button>
        
        <span>
          Страница {page} из {pages} (Всего: {total})
        </span>
        
        <button onClick={nextPage} disabled={!hasNext}>
          Вперед
        </button>
      </div>
    </div>
  );
};

export default DataTable;
```

### 3. Компонент формы с валидацией
```javascript
// src/components/Form.js
import React, { useState } from 'react';

const Form = ({ 
  fields, 
  onSubmit, 
  initialValues = {}, 
  submitText = "Отправить" 
}) => {
  const [formData, setFormData] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [submitting, setSubmitting] = useState(false);

  const handleChange = (name, value) => {
    setFormData(prev => ({ ...prev, [name]: value }));
    // Очистить ошибку при вводе пользователя
    if (errors[name]) {
      setErrors(prev => ({ ...prev, [name]: '' }));
    }
  };

  const validate = () => {
    const newErrors = {};
    
    fields.forEach(field => {
      if (field.required && !formData[field.name]) {
        newErrors[field.name] = `${field.label} обязателен для заполнения`;
      }
      
      if (field.validate) {
        const error = field.validate(formData[field.name]);
        if (error) {
          newErrors[field.name] = error;
        }
      }
    });
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    if (!validate()) return;
    
    setSubmitting(true);
    try {
      await onSubmit(formData);
    } catch (error) {
      console.error('Ошибка отправки формы:', error);
    } finally {
      setSubmitting(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="form">
      {fields.map(field => (
        <div key={field.name} className="form-field">
          <label htmlFor={field.name}>{field.label}</label>
          {field.type === 'select' ? (
            <select
              id={field.name}
              value={formData[field.name] || ''}
              onChange={(e) => handleChange(field.name, e.target.value)}
            >
              {field.options?.map(option => (
                <option key={option.value} value={option.value}>
                  {option.label}
                </option>
              ))}
            </select>
          ) : (
            <input
              type={field.type || 'text'}
              id={field.name}
              value={formData[field.name] || ''}
              onChange={(e) => handleChange(field.name, e.target.value)}
              placeholder={field.placeholder}
            />
          )}
          {errors[field.name] && (
            <span className="error">{errors[field.name]}</span>
          )}
        </div>
      ))}
      
      <button type="submit" disabled={submitting}>
        {submitting ? 'Отправка...' : submitText}
      </button>
    </form>
  );
};

export default Form;
```

## Вспомогательные функции

### 1. Утилиты обработки ошибок
```javascript
// src/utils/errorHandler.js
export const handleApiError = (error, showToast) => {
  if (error.response) {
    const { status, data } = error.response;
    
    switch (status) {
      case 400:
        showToast(data.message || 'Неверный запрос', 'error');
        break;
      case 401:
        localStorage.removeItem('accessToken');
        localStorage.removeItem('refreshToken');
        window.location.href = '/login';
        break;
      case 403:
        showToast('Доступ запрещен', 'error');
        break;
      case 404:
        showToast('Ресурс не найден', 'error');
        break;
      case 422:
        if (Array.isArray(data.message)) {
          data.message.forEach(msg => showToast(msg, 'error'));
        } else {
          showToast(data.message, 'error');
        }
        break;
      case 500:
        showToast('Произошла ошибка сервера', 'error');
        break;
      default:
        showToast(data.message || 'Произошла ошибка', 'error');
    }
  } else if (error.request) {
    showToast('Ошибка сети - проверьте подключение', 'error');
  } else {
    showToast('Произошла непредвиденная ошибка', 'error');
  }
};

export const formatErrorMessage = (error) => {
  if (error.response?.data?.message) {
    return error.response.data.message;
  }
  return error.message || 'Произошла ошибка';
};
```

### 2. Утилиты форматирования дат
```javascript
// src/utils/dateUtils.js
export const formatDate = (date) => {
  return new Date(date).toLocaleDateString('ru-RU');
};

export const formatDateTime = (date) => {
  return new Date(date).toLocaleString('ru-RU');
};

export const formatCurrency = (amount) => {
  return new Intl.NumberFormat('ru-RU', {
    style: 'currency',
    currency: 'RUB'
  }).format(amount);
};

export const formatDateRange = (startDate, endDate) => {
  const start = formatDate(startDate);
  const end = formatDate(endDate);
  return `${start} - ${end}`;
};
```

### 3. Утилиты локального хранилища
```javascript
// src/utils/storage.js
export const storage = {
  set: (key, value) => {
    try {
      localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.error('Ошибка записи в хранилище:', error);
    }
  },
  
  get: (key, defaultValue = null) => {
    try {
      const item = localStorage.getItem(key);
      return item ? JSON.parse(item) : defaultValue;
    } catch (error) {
      console.error('Ошибка чтения из хранилища:', error);
      return defaultValue;
    }
  },
  
  remove: (key) => {
    try {
      localStorage.removeItem(key);
    } catch (error) {
      console.error('Ошибка удаления из хранилища:', error);
    }
  },
  
  clear: () => {
    try {
      localStorage.clear();
    } catch (error) {
      console.error('Ошибка очистки хранилища:', error);
    }
  }
};
```

## Конфигурация среды

### 1. Переменные окружения
```bash
# .env.local
REACT_APP_API_URL=https://api.erp-system.com/v1
REACT_APP_WS_URL=wss://api.erp-system.com/ws
REACT_APP_DEFAULT_PAGE_SIZE=20
```

### 2. Файл конфигурации
```javascript
// src/config/index.js
const config = {
  apiUrl: process.env.REACT_APP_API_URL || 'http://localhost:3000/api/v1',
  wsUrl: process.env.REACT_APP_WS_URL || 'ws://localhost:3000/ws',
  defaultPageSize: parseInt(process.env.REACT_APP_DEFAULT_PAGE_SIZE || '20'),
  appVersion: process.env.REACT_APP_VERSION || '1.0.0'
};

export default config;
```

## Паттерны тестирования

### 1. Настройка моков API
```javascript
// src/__mocks__/api.js
export const mockApi = {
  get: jest.fn(),
  post: jest.fn(),
  put: jest.fn(),
  delete: jest.fn()
};

// Мок успешного ответа
export const mockSuccessResponse = (data) => ({
  data,
  status: 200,
  statusText: 'OK'
});

// Мок ответа об ошибке
export const mockErrorResponse = (error, status = 500) => ({
  response: {
    data: { message: error },
    status,
    statusText: 'Error'
  }
});
```

### 2. Пример теста компонента
```javascript
// src/components/__tests__/DataTable.test.js
import React from 'react';
import { render, screen, waitFor } from '@testing-library/react';
import DataTable from '../DataTable';
import { usePagination } from '../../hooks/usePagination';

jest.mock('../../hooks/usePagination');

describe('DataTable', () => {
  const mockColumns = [
    { key: 'id', label: 'ID' },
    { key: 'name', label: 'Имя' }
  ];

  const mockData = [
    { id: 1, name: 'Элемент 1' },
    { id: 2, name: 'Элемент 2' }
  ];

  beforeEach(() => {
    usePagination.mockReturnValue({
      data: mockData,
      page: 1,
      limit: 20,
      total: 2,
      pages: 1,
      hasNext: false,
      hasPrev: false,
      nextPage: jest.fn(),
      prevPage: jest.fn(),
      goToPage: jest.fn(),
      fetchPage: jest.fn(),
      loading: false,
      error: null
    });
  });

  it('рендерит таблицу с данными', async () => {
    render(<DataTable resource="users" columns={mockColumns} />);
    
    await waitFor(() => {
      expect(screen.getByText('Элемент 1')).toBeInTheDocument();
      expect(screen.getByText('Элемент 2')).toBeInTheDocument();
    });
  });

  it('показывает состояние загрузки', () => {
    usePagination.mockReturnValueOnce({
      ...usePagination(),
      loading: true
    });
    
    render(<DataTable resource="users" columns={mockColumns} />);
    expect(screen.getByText('Загрузка...')).toBeInTheDocument();
  });
});
```

Это руководство быстрого доступа предоставляет фронтенд-разработчикам готовые к использованию паттерны и компоненты для эффективной интеграции с API ERP-сервера.